---
title: "Roost classifications"
format: html
editor: source
---

Load packages
```{r}
library(vultureUtils)
library(tidyverse)
library(gganimate)
library(dendextend)
library(sf)
library(fpc)
library(paletteer)
library(leaflet)
```

Load data
```{r}
load("data/datAnnotCleaned.Rda")
```

Get roost classifications
```{r}
roosts <- vultureUtils::get_roosts_df(df = datAnnotCleaned, id = "trackId")
simplifiedRoosts <- roosts %>%
  dplyr::select(trackId, location_long, location_lat, roost_date)

# double-check that we just have one roost per individual per night
simplifiedRoosts %>%
  group_by(trackId, roost_date) %>%
  summarize(n = n()) %>%
  pull(n) %>%
  table()
```

Make some plots

```{r}
simplifiedRoosts %>%
  ggplot(aes(x = location_long, y = location_lat))+
  geom_point(alpha = 0.2)+
  theme_classic()+
  theme(legend.position = "none")+
  coord_equal()
```

What if we facet by year?
```{r}
simplifiedRoosts <- simplifiedRoosts %>%
  mutate(year = lubridate::year(roost_date))

years <- simplifiedRoosts %>%
  group_by(year) %>%
  group_split(.keep = T)

simplifiedRoosts %>%
  ggplot(aes(x = location_long, y = location_lat))+
  geom_point(alpha = 0.2)+
  theme_classic()+
  theme(legend.position = "none")+
  facet_wrap(~year)
```

Just as an experiment, let's look at the roosts each day.

```{r}
anim <- simplifiedRoosts %>%
  #filter(year == 2020) %>%
  mutate(time = as.numeric(factor(roost_date))) %>%
  ggplot(aes(x = location_long, y = location_lat, group = trackId))+
  geom_point(size = 5, aes(col = factor(year)))+
  theme_classic()+
  scale_color_brewer(name = "Year", palette = "Dark2")+
  #theme(legend.position = "none")+
  transition_time(time)+
  shadow_mark(color = "black", alpha = 0.1, size = 2)+
  ggtitle("Roost locations over time")

animate(anim, fps = 4)
anim_save("data/roostLocations.gif", anim)
```

## K-means clustering

K-means clustering really isn't going to work for our use case. Here is an example with 50 clusters.

```{r}
roostLocs <- simplifiedRoosts %>%
  dplyr::select(location_long, location_lat)
clusters <- kmeans(x = roostLocs, centers = 50)
centers <- clusters$centers
assignments <- clusters$cluster

simplifiedRoosts <- simplifiedRoosts %>%
  mutate(cluster = assignments)
```

```{r}
simplifiedRoosts %>%
  ggplot(aes(x = location_long, y = location_lat, col = factor(cluster)))+
  geom_point(alpha = 0.5)+
  theme_classic()+
  theme(legend.position = "none")
```
Okay, we could do k-means clustering with any arbitrary number and get *some* result. But I'm not sure how meaningful that is.

## Try hierarchical clustering

```{r}
?distm # default unit here is meters, which is what we want!
testDF <- years[[2]] %>%
  sf::st_as_sf(coords = c("location_long", "location_lat"), remove = F) %>%
  sf::st_set_crs("WGS84")

# Compute pairwise distances between points
# distanceMatrix <- sf::st_distance(testDF, testDF) %>% as.dist() # this takes a really really long time with such a big dataset.
# save(distanceMatrix, file = "data/distanceMatrix.Rda")
load("data/distanceMatrix.Rda")
```

```{r}
# Do clustering
clust <- hclust(d = distanceMatrix, method = "complete")
plot(clust, labels = F)

# Cut the dendrogram into different numbers of clusters
numberCuts <- as.data.frame(cutree(clust, k = c(30, 40, 50, 60)))
names(numberCuts) <- paste0("k_", names(numberCuts))

# Alternatively, cut the dendrogram based on different distances
distanceCuts <- as.data.frame(cutree(clust, h = c(250, 500, 1000, 2000)))
names(distanceCuts) <- paste0("dist_", names(distanceCuts))

# Create a data frame
testDF_withClusters <- bind_cols(testDF, numberCuts, distanceCuts)
```

Make plots--numbers

```{r}
plots_numbers <- map(names(testDF_withClusters)[grepl("k_", names(testDF_withClusters))], ~{
  n <- str_extract(.x, "[0-9]+")
  testDF_withClusters %>%
    ggplot(aes(x = location_long, y = location_lat, col = as.factor(.data[[.x]])))+
    geom_point(alpha = 0.3)+
    theme_classic()+
    theme(legend.position = "none")+
    coord_equal()+
    ggtitle(paste0("Number of clusters = ", n))
})
walk(plots_numbers, print)
```

Make plots--distances

```{r}
plots_distances <- map(names(testDF_withClusters)[grepl("dist_", names(testDF_withClusters))], ~{
  testDF_withClusters %>%
    ggplot(aes(x = location_long, y = location_lat, col = as.factor(.data[[.x]])))+
    geom_point(alpha = 0.3)+
    theme_classic()+
    theme(legend.position = "none")+
    coord_equal()
})
walk(plots_distances, print)
```

Ok, if we cut the tree based on distances, what does the number of clusters look like?
```{r}
# number of clusters
dists <- seq(100, 2000, by = 100)
testDistanceCuts <- as.data.frame(cutree(clust, h = dists))
nClusters <- map_dbl(testDistanceCuts, max)
plot(nClusters~dists, type = "l")
# This is not particularly helpful for selecting the distance. I suppose we could look at the elbow, which is a bit lower than 500m. 1000m seems like a potentially relevant distance, though, so I'm going to go with that for now, I guess? Note that even at a distance of 1000, we still get about 500 unique roosts.
```

Continuing with a 1000m (1km) distance for roosts

Zoom in on just the center of the map and visualize the different numbers
```{r}
zoomData <- testDF_withClusters %>%
  filter(location_lat < 31.8, location_lat > 30.5, location_long < 35.4, location_long > 34.6)

plots_numbers_zoom <- map(names(zoomData)[grepl("k_", names(zoomData))], ~{
  n <- str_extract(.x, "[0-9]+")
  zoomData %>%
    ggplot(aes(x = location_long, y = location_lat, col = as.factor(.data[[.x]])))+
    geom_point(alpha = 0.3)+
    theme_classic()+
    theme(legend.position = "none")+
    coord_equal()+
    ggtitle(paste0("Number of clusters = ", n))
})
walk(plots_numbers_zoom, print)
```

## DBSCAN clustering

I think DBSCAN will be a good clustering algorithm here because it can identify weird-shaped clusters, and because the parameters that need tuning can be biologically informed. It will also tell us which points are outliers, and we can then do whatever we want with outliers (e.g. assign them to their own roosts)

```{r}
set.seed(3)
# eps is the reachability distance. I'm going to consider that to be 750m for starters. minPts for a core point is going to be 3.
dbscan <- dbscan(distanceMatrix, eps = 750, method = "dist", MinPts = 3)

data_dbscan <- bind_cols(testDF, "cluster" = dbscan$cluster) %>%
  mutate(isOutlier = case_when(cluster == 0 ~ T,
                               TRUE ~ F))

# plot
data_dbscan %>%
  ggplot(aes(x = location_long, y = location_lat, col = factor(cluster)))+
  geom_point(alpha = 0.3, aes(shape = isOutlier))+
  scale_shape_manual(values = c(19, 3))+
  theme_classic()+
  theme(legend.position = "none")+
  coord_equal()

# zoom in
data_dbscan %>%
  filter(location_lat < 31.2, location_lat > 30.9, location_long < 35.4, location_long > 35.0) %>%
  ggplot(aes(x = location_long, y = location_lat, col = factor(cluster)))+
  geom_point(alpha = 0.3, aes(shape = isOutlier))+
  scale_shape_manual(values = c(19, 3))+
  theme_classic()+
  theme(legend.position = "none")+
  coord_equal()
```

How many points are classified as outliers?

```{r}
nPoints <- nrow(testDF)
dists <- c(100, 250, 500, 750, 1000, 1500)
minpts <- 3
dbscans_list <- vector(mode = "list", length = length(dists))
for(i in 1:length(dists)){
  dbscans_list[[i]] <- fpc::dbscan(distanceMatrix, eps = dists[i], method = "dist", MinPts = minpts)
}
data_dbscans <- map(dbscans_list, ~bind_cols(testDF, "cluster" = .x$cluster) %>%
                      mutate(isOutlier = ifelse(cluster == 0, T, F)))
nOutliers <- map_dbl(data_dbscans, ~.x %>%
                       filter(cluster == 0) %>%
                       nrow())
outliers <- data.frame(dist = dists, 
                       nOutliers = nOutliers,
                       propOutliers = nOutliers/nPoints)

outliers %>%
  ggplot(aes(x = dist, y = propOutliers))+
  geom_point(size = 2)+
  geom_line()+
  theme_classic()+
  ylab("Proportion of points not included in a cluster")+
  xlab("Neighborhood distance (m)")
```
Make zoomed-in plots for each dbscan distance
```{r}
set.seed(1)
zoomPlots <- map2(data_dbscans, dists, ~{
  yr <- min(lubridate::year(.x$roost_date))
  .x %>%
    filter(location_lat < 31.8, location_lat > 30.5, location_long < 35.4, location_long > 34.6) %>%
    ggplot(aes(x = location_long, y = location_lat, col = factor(cluster)))+
    geom_point(alpha = 0.3, aes(shape = isOutlier))+
    scale_shape_manual(values = c(19, 3))+
    theme_classic()+
    theme(legend.position = "none")+
    coord_equal()+
    ggtitle(paste0("Year = ", yr, "; MinPts = ", minpts, "; eps = ", .y, "m"))+
    scale_color_paletteer_d("trekcolors::lcars_cardassian")
})

walk(zoomPlots, print)
```

Visualize these options in leaflet, with the existing roost polygons
```{r}
# Load the roost polygons
roostPolygons <- sf::st_read("data/AllRoostPolygons.kml") %>%
  select(-c("Name", "Description"))
```

