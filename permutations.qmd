---
title: "Permutations"
format: html
editor: source
---

# Setup
## Load packages
```{r}
library(tidyverse)
library(vultureUtils)
library(igraph)
library(feather)
library(sf)
library(profvis) # to see what's slowing the code down
```

## Load annotated data
```{r}
load("data/datAnnotCleaned.Rda")
# make this into an sf object:
datAnnotCleaned <- datAnnotCleaned %>%
  sf::st_as_sf(coords = c("location_long.1", "location_lat.1")) %>%
  sf::st_set_crs("WGS84") %>%
  mutate(timeOnly = stringr::str_extract(as.character(timestamp), "[0-9]{2}:[0-9]{2}:[0-9]{2}"))
roostPolygons <- sf::st_read("data/roosts25_cutOffRegion.kml", quiet = TRUE) %>%
  sf::st_transform("WGS84") %>%
  select(-c("Name", "Description"))
```

## Annotate for seasons
```{r}
# Breeding: December through June
# Non-breeding: July through November
datAnnotCleaned <- datAnnotCleaned %>%
  mutate(season = case_when(lubridate::month(timestamp) %in% c(1:6) ~ "breeding_thisyear",
                            lubridate::month(timestamp) == 12 ~ "breeding_nextyear",
                            lubridate::month(timestamp) %in% c(7:11) ~ "nonbreeding",
                            TRUE ~ NA_character_),
         year = lubridate::year(timestamp),
         seasonUnique = case_when(season == "breeding_thisyear" ~ paste(year, "breeding", sep = "_"),
                                  season == "breeding_nextyear" ~ paste(year+1, "breeding", sep = "_"),
                                  season == "nonbreeding" ~ paste(year, "nonbreeding", sep = "_")))
```

I had to treat the seasons weirdly above to account for the fact that there are months in a given calendar year that are considered to be part of two different breeding seasons.

Now we can split the data by season:
```{r}
seasons <- datAnnotCleaned %>%
  group_by(seasonUnique) %>%
  group_split(.keep = T)
length(seasons)
```

# Observed networks (as a basis for comparison)

## Get edge lists
### Co-flight (1000 meters)
```{r}
#flightNetworks <- purrr::map(seasons, ~vultureUtils::getFlightEdges(dataset = .x, roostPolygons = roostPolygons, distThreshold = 1000, return = "both"))
#save(flightNetworks, file = "data/flightNetworks.Rda")
load("data/flightNetworks.Rda")
```

### Co-flight (50  meters)
```{r}
#feedingNetworks <- purrr::map(seasons, ~vultureUtils::getFeedingEdges(dataset = ., roostPolygons = roostPolygons, distThreshold = 50, return = "both"))
#save(feedingNetworks, file = "data/feedingNetworks.Rda")
load("data/feedingNetworks.Rda")
```

### Co-roosting (distance-based, 500 meters)

# First, have to obtain roost locations for this dataset.
```{r}
#roosts <- map(seasons, ~vultureUtils::get_roosts_df(.x, id = "trackId"))
#save(roosts, file = "data/roosts.Rda")
load("data/roosts.Rda")
```

```{r}
#roostNetworks_distance <- map(roosts, ~vultureUtils::getRoostEdges(dataset = .x, mode = "distance", distThreshold = 500, return = "both"))
#save(roostNetworks_distance, file = "data/roostNetworks_distance.Rda")
load("data/roostNetworks_distance.Rda")
```

### Co-roosting (polygon-based)
```{r}
testPolygon <- vultureUtils::getRoostEdges(dataset = roosts[[6]], mode = "polygon", roostPolygons = roostPolygons, return = "both")
roostNetworks_polygon <- map(roosts, ~vultureUtils::getRoostEdges(dataset = .x, mode = "polygon", roostPolygons = roostPolygons, return = "both"))
```



## Create networks

```{r}
# Flight
obs_flight_w <- map(obs_flightEdges_bySeason, ~vultureUtils::makeGraph(.x$edges, weighted = TRUE, vertices = .x$allVertices))
obs_flight_uw <- map(obs_flightEdges_bySeason, ~vultureUtils::makeGraph(.x$edges, weighted = FALSE, vertices = .x$allVertices))

# Feeding
obs_feeding_w <- map(obs_feedingEdges_bySeason, ~vultureUtils::makeGraph(.x$edges, weighted = TRUE, vertices = .x$allVertices))
obs_feeding_uw <- map(obs_feedingEdges_bySeason, ~vultureUtils::makeGraph(.x$edges, weighted = FALSE, vertices = .x$allVertices))
```

## Measure networks
XXX do some measurement

# Orr-style permutations (shuffling days)

For now, I'm just going to work with the 2021-2022 breeding season, `b_21_22`. Later, can expand the analyses to the other seasons.

Also for now, I'm going to restrict it to individuals that were present on all of the days. Just simpler to think about.

## Setup

```{r}
# Get restricted data: only individuals that were present on all of the days.
maxDates <- max(dates$b_21_22$nUniqueDates)
whichIndivs <- dates$b_21_22 %>%
  filter(nUniqueDates == maxDates) %>%
  pull(trackId) %>%
  unique()
b_21_22_restricted <- seasons$b_21_22 %>%
  filter(trackId %in% whichIndivs)

# for the sake of speed in testing these permutations, I'm going to limit it even more: just the first 30 days.
testShort <- b_21_22_restricted %>%
  filter(dateOnly %in% sort(unique(b_21_22_restricted$dateOnly))[1:30])
nrow(testShort)
```

## Unrestricted permutation
### Shuffle data

Separate into a list of individuals and permute each individual

```{r}
indivs <- testShort %>%
  sf::st_drop_geometry() %>%
  group_by(trackId) %>%
  group_split(.keep = T)

permutationFunction <- function(indiv){
  # get unique dates as a vector
  uniqueDates <- unique(indiv$dateOnly)
  
  # shuffle the dates vector
  shuffledDates <- sample(uniqueDates, size = length(uniqueDates), replace = F)
  
  # Join the permuted dates
  permutedIndiv <- indiv %>%
    dplyr::left_join(data.frame("dateOnly" = uniqueDates,
                                "permuted_dateOnly" = shuffledDates), 
                     by = "dateOnly")
  
  return(permutedIndiv)
}

# Run the permutations (let's start with 100, since it takes so long)
set.seed(3)
nPermutations <- 100
permutations <- vector(mode = "list", length = nPermutations)
for(i in 1:nPermutations){
  permutations[[i]] <- map_dfr(indivs, permutationFunction)
  cat(".")
  #beepr::beep(sound = 1)
}

permutations <- map(permutations, ~{
  # change names to remove the original date/time columns. Need to do this so it will work with makeGraph.
  .x %>%
    mutate(timeOnly = lubridate::hms(timeOnly),
           permuted_timestamp = permuted_dateOnly + timeOnly) %>%
    dplyr::select(-c(dateOnly, timestamp, timeOnly)) %>%
    dplyr::rename("timestamp" = permuted_timestamp,
                  "dateOnly" = permuted_dateOnly) %>%
    sf::st_as_sf(coords = c("location_long", "location_lat")) %>%
    sf::st_set_crs("WGS84")
})

save(permutations, file = "data/permutations.Rda")
load("data/permutations.Rda")
```

### Create networks
#### Get edge lists

```{r}
# Get edge lists
# flightEdges_permuted <- map(permutations, ~vultureUtils::getFlightEdges(dataset = .x, roostPolygons = roostPolygons, distThreshold = 350, includeAllVertices = T))
# save(flightEdges_permuted, file = "data/flightEdges_permuted.Rda")
load("data/flightEdges_permuted.Rda")
# feedingEdges_permuted <- map(permutations, ~vultureUtils::getFeedingEdges(dataset = .x, roostPolygons = roostPolygons, includeAllVertices = T))
# save(feedingEdges_permuted, file = "data/feedingEdges_permuted.Rda")
load("data/feedingEdges_permuted.Rda")

# Get observed edge lists for the same period
obs_feedingEdges_subset <- obs_feedingEdges_bySeason$b_21_22$edges %>%
  filter(minTimestamp >= min(feedingEdges_permuted[[1]]$edges$minTimestamp, na.rm = T),
         maxTimestamp <= max(feedingEdges_permuted[[1]]$edges$maxTimestamp, na.rm = T))
obs_feedingEdges_subset <- list("edges" = obs_feedingEdges_subset, "allVertices" = obs_feedingEdges_bySeason$b_21_22$allVertices)

obs_flightEdges_subset <- obs_flightEdges_bySeason$b_21_22$edges %>%
  filter(minTimestamp >= min(flightEdges_permuted[[1]]$edges$minTimestamp, na.rm = T),
         maxTimestamp <= max(flightEdges_permuted[[1]]$edges$maxTimestamp, na.rm = T))
obs_flightEdges_subset <- list("edges" = obs_flightEdges_subset, "allVertices" = obs_flightEdges_bySeason$b_21_22$allVertices)
```

#### Create networks

```{r}
# Flight
flight_w_permuted <- map(flightEdges_permuted, ~vultureUtils::makeGraph(.x$edges, weighted = T, vertices = .x$allVertices))
flight_uw_permuted <- map(flightEdges_permuted, ~vultureUtils::makeGraph(.x$edges, weighted = F, vertices = .x$allVertices))
flight_w_obs <- vultureUtils::makeGraph(obs_flightEdges_subset$edges, weighted = T, vertices = obs_flightEdges_subset$allVertices)
flight_uw_obs <- vultureUtils::makeGraph(obs_flightEdges_subset$edges, weighted = F, vertices = obs_flightEdges_subset$allVertices)

# Feeding
feeding_w_permuted <- map(feedingEdges_permuted, ~vultureUtils::makeGraph(.x$edges, weighted = T, vertices = .x$allVertices))
feeding_uw_permuted <- map(feedingEdges_permuted, ~vultureUtils::makeGraph(.x$edges, weighted = F, vertices = .x$allVertices))
feeding_w_obs <- vultureUtils::makeGraph(obs_feedingEdges_subset$edges, weighted = T, vertices = obs_feedingEdges_subset$allVertices)
feeding_uw_obs <- vultureUtils::makeGraph(obs_feedingEdges_subset$edges, weighted = F, vertices = obs_feedingEdges_subset$allVertices)
```

Network-level metrics
```{r}
# density
dens_p_flight <- map_dbl(flight_uw_permuted, igraph::edge_density)
dens_p_feeding <- map_dbl(feeding_uw_permuted, igraph::edge_density)
dens_o_flight <- edge_density(flight_uw_obs)
dens_o_feeding <- edge_density(feeding_uw_obs)

densDF <- data.frame(situation = c(rep("flight", length(dens_p_flight) + 1), rep("feeding", length(dens_p_feeding) + 1)),
                     density = c(dens_p_flight, dens_o_flight, dens_p_feeding, dens_o_feeding),
                     type = c(rep("permuted", length(dens_p_flight)), "observed", rep("permuted", length(dens_p_feeding)), "observed"))

ggplot(data = densDF %>%
         filter(type == "permuted"),
       aes(x = density))+
  geom_histogram()+
  theme_classic()+
  facet_wrap(~situation, scales = "free")+
  geom_vline(data = densDF %>%
               filter(type == "observed"), aes(xintercept = density), col = "red")
```

```{r}
# degree distribution
dd_p_flight <- map(flight_uw_permuted, ~enframe(degree(.x))) %>%
  data.table::rbindlist(idcol = "iter") %>%
  mutate(type = "permuted",
         situation = "flight")

dd_p_feeding <- map(feeding_uw_permuted, ~enframe(degree(.x))) %>%
  data.table::rbindlist(idcol = "iter") %>%
  mutate(type = "permuted",
         situation = "feeding")

dd_o_flight <- degree(flight_uw_obs) %>% 
  enframe() %>% 
  mutate(iter = 0, type = "observed", situation = "flight")

dd_o_feeding <- degree(feeding_uw_obs) %>%
  enframe() %>% 
  mutate(iter = 0, type = "observed", situation = "feeding")

degreeDF <- bind_rows(dd_p_flight, dd_o_flight, dd_p_feeding, dd_o_feeding)

degreeDF %>%
  ggplot(aes(x = value, col = type, group = iter))+
  geom_density()+
  facet_wrap(~situation, scales = "free")+
  theme_classic()+
  ylab("")+
  xlab("Degree") # for any of this to mean anything, need to include way more data, which means I need to make the functions go faster.
```

XXX next to do:
- [DONE] use a smaller subset of the days (10 days? vs 60 that i have now) to test out benchmarking to get the code to run faster. 
- [DONE] change network code so that it includes all possible vertices. This one's really important, since it has a big effect on things like density.
- dig more into how to benchmark code, in order to speed up the incredibly slow steps here. 
- set up this project on the cluster so that I can run these things without wearing out my laptop
- scale up to dealing with more data. I have to drastically improve the function performance if it's going to make sense to do this.

- make roost networks! distance only, and cluster-based.
- write a function to make roost networks based either on distance or on a vector of cluster assignments.


### Measure networks
## Distance-restricted permutation
### Shuffle data
### Create networks
### Measure networks

# Noa-style permutations (shifting entire tracks)

## Determining number of days to shift (min, max)
### Min: Spatial autocorrelation analysis
## Create networks
## Measure networks
