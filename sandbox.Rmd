---
title: "Sandbox"
author: "Kaija Gahm"
date: "2022-10-04"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(vultureUtils)
library(igraph)
library(elevatr) # for getting elevation data
library(suncalc) # for calculating sunrise and sunset
source("RST_functions_all.R")
dyn.load("RST_residenceRadii.so")
library(ggmap)
source("bboxFromRad.R")
library(units)
library(tidyverse)
library(sf)
```

Let's look at the presence of the vultures over time.

```{r}
load("data/dat.Rda")
unique(dat$trackId)
dates <- dat %>%
  dplyr::select(trackId, dateOnly) %>%
  distinct()

dates %>%
  ggplot(aes(x = trackId, y = dateOnly))+
  geom_point(size = 0.2)+
  coord_flip()
```
Now I'd like to annotate this data with periods to remove
```{r}
toRemove <- read.csv("data/whoswho_vultures11Jul22_new.xlsx - periods_to_remove.csv") %>%
  mutate(across(everything(), .fns = function(x){str_replace_all(x, pattern = "\t", replacement = "")}))
head(toRemove)
toRemove <- toRemove %>%
  dplyr::select("trackId" = Movebank_id,
                remove_start,
                remove_end,
                reason) %>%
  mutate(remove_start = stringr::str_remove(remove_start, pattern = ".*day, "),
         remove_end = stringr::str_remove(remove_end, pattern = ".*day, ")) %>%
  mutate(across(c(remove_start, remove_end), .fns = function(x){
    as.Date(lubridate::parse_date_time2(x, orders = c("%B%d%Y", "%Y%m%d")))
  })) %>%
  dplyr::filter(!is.na(remove_end))

toRemove_long <- toRemove %>%
  group_by(trackId, reason) %>%
  # sequence of daily dates for each corresponding start, end elements
  dplyr::mutate(dateOnly = map2(remove_start, remove_end, seq, by = "1 day")) %>%
  # unnest the list column
  unnest(cols = c(dateOnly)) %>% 
  # remove any duplicate rows
  distinct() %>%
  dplyr::select(-c(remove_start, remove_end)) %>%
  rename("status" = reason)

# Join to the original data
datAnnot <- dat %>%
  left_join(toRemove_long, by = c("trackId", "dateOnly")) %>%
  mutate(status = replace_na(status, "valid"))

# Plot, coloring by the vulture status
datAnnot %>%
  dplyr::select(trackId, dateOnly, status) %>%
  distinct() %>%
  ggplot(aes(x = trackId, y = dateOnly, col = status))+
  geom_point(size = 0.2)+
  coord_flip()+
  guides(col = guide_legend(override.aes = list(size = 10)))+
  scale_color_viridis_d()

# Try again, just removing the invalid data.
datAnnot %>%
  filter(status == "valid") %>%
  dplyr::select(trackId, dateOnly) %>%
  distinct() %>%
  ggplot(aes(x = trackId, y = dateOnly))+
  geom_point(size = 0.2)+
  coord_flip()

# Now we can sort by a couple different things
## Compute start date, end date, and longest consecutive run.
metrics <- datAnnot %>%
  filter(status == "valid") %>%
  dplyr::select(trackId, dateOnly) %>%
  distinct() %>%
  group_by(trackId) %>%
  group_by(cumsum(c(0, diff(dateOnly) - 1))) %>%
  mutate(consecLen = n()) %>%
  ungroup() %>%
  group_by(trackId) %>%
  summarize(startDate = min(dateOnly),
            endDate = max(dateOnly),
            longestRun = max(consecLen))

datAnnot <- datAnnot %>%
  left_join(metrics, by = "trackId")

# Plot, sorting by earliest start date
datAnnot %>%
  filter(status == "valid") %>%
  mutate(trackId = forcats::fct_reorder(trackId, startDate, .desc = T)) %>%
  dplyr::select(trackId, dateOnly) %>%
  distinct() %>%
  ggplot(aes(x = trackId, y = dateOnly))+
  geom_point(size = 0.2)+
  coord_flip()

# Plot, sorting by earliest end date
datAnnot %>%
  filter(status == "valid") %>%
  mutate(trackId = forcats::fct_reorder(trackId, endDate, .desc = T)) %>%
  dplyr::select(trackId, dateOnly) %>%
  distinct() %>%
  ggplot(aes(x = trackId, y = dateOnly))+
  geom_point(size = 0.2)+
  coord_flip()

# Plot, sorting by longest run
datAnnot %>%
  filter(status == "valid") %>%
  mutate(trackId = forcats::fct_reorder(trackId, longestRun)) %>%
  dplyr::select(trackId, dateOnly) %>%
  distinct() %>%
  ggplot(aes(x = trackId, y = dateOnly))+
  geom_point(size = 0.2)+
  coord_flip()
```
Okay, in order to get more complete mortality data, I'm going to need to add on the INPA data.

## Arrival at carcasses

Let's move on to examining an individual's movement patterns to identify arrival at a carcass site.
Going to pick the individual with the longest run
```{r}
targetIndiv <- datAnnot %>%
  dplyr::select(trackId, longestRun) %>%
  distinct() %>%
  arrange(-longestRun) %>%
  slice(1) %>%
  pull(trackId)

track <- datAnnot %>%
  filter(trackId == targetIndiv)

trackDays <- track %>%
  group_by(dateOnly) %>%
  group_split(.keep = TRUE)
```

Visualize acceleration
```{r}
acc <- track %>%
  dplyr::select(dateOnly, timestamp, contains("acceleration_")) %>%
  pivot_longer(cols = contains("acceleration_"), names_to = "axis", values_to = "acceleration") %>%
  mutate(axis = str_remove(axis, "acceleration_raw_"))

acc %>%
  ggplot(aes(x = timestamp, y = acceleration, col = axis))+
  geom_line()
```
Okay, that's not very informative, as expected. Let's split this by day and just look at one day's sequence.

```{r}
accDays <- lapply(trackDays, function(x){
  x %>% dplyr::select(dateOnly, timestamp, contains("acceleration_")) %>%
    pivot_longer(cols = contains("acceleration_"), names_to = "axis", values_to = "acceleration") %>%
    mutate(axis = str_remove(axis, "acceleration_raw_"))
})
```

```{r}
randomDay <- sample(1:length(accDays), size = 1)

accDays[[randomDay]] %>%
  ggplot(aes(x = timestamp, y = acceleration, col = axis))+
  geom_line()
```
Okay, this is kind of cool. But I'm not good enough at interpreting accelerometer data to know for sure how to read this.

What about speed and altitude? Can the combination of those tell us what we need to know?
```{r}
randomDay <- sample(1:length(accDays), size = 1)
speed <- trackDays[[randomDay]] %>%
  ggplot(aes(x = timestamp, y = ground_speed))+
  geom_line()
speed

altitude <- trackDays[[randomDay]] %>%
  ggplot(aes(x = timestamp, y = height_above_msl))+
  geom_line()
altitude
```

In order for this to make any sense at all, we need to cross-reference these measurements with elevation data for Israel. We can obtain this using the `elevatr` package.

```{r}
# Add sunrise and sunset information using suncalc
## first let's get the mean lat and long for the current track
meanLat <- mean(track$location_lat)
meanLong <- mean(track$location_long)
dates <- seq(from = min(track$dateOnly), to = max(track$dateOnly), by = "1 day")
sunriseSunset <- suncalc::getSunlightTimes(date = dates, lat = meanLat, lon = meanLong, keep = c("sunrise", "sunset")) %>%
  dplyr::select("dateOnly" = date, sunrise, sunset)
track <- track %>%
  left_join(sunriseSunset, by = "dateOnly")

# Make it an sf object and add elevation
trackSF <- track %>%
  sf::st_as_sf(., coords = c("location_long", "location_lat"), crs = "WGS84")
elevs <- elevatr::get_elev_raster(trackSF, z = 12) 
trackSF$groundElev <- raster::extract(x = elevs, y = trackSF)
trackSF <- trackSF %>%
  mutate(height_above_ground = height_above_msl - groundElev)

# let's set anything below 0 to 0.
trackSF <- trackSF %>%
  mutate(height_above_ground = case_when(height_above_ground < 0 ~ 0,
                                         TRUE ~ height_above_ground))

trackDaysSF <- trackSF %>%
  group_by(dateOnly) %>%
  group_split(.keep = TRUE)
```

Now let's re-do the speed and altitude plots, using altitude above ground:
```{r}
# create rectangles to add to ggplot, assuming the dataset has the "sunrise" and "sunset" and "timestamp" columns.
sunriseSunsetBars <- list(geom_rect(aes(xmin = min(timestamp),
                                        xmax = min(sunrise),
                                        ymin = -Inf,
                                        ymax = Inf), alpha = 0.003),
                          geom_rect(aes(xmin = max(sunset),
                                        xmax = max(timestamp),
                                        ymin = -Inf,
                                        ymax = Inf), alpha = 0.003))

randomDay <- sample(1:length(trackDaysSF), size = 1)

altitude <- trackDaysSF[[randomDay]] %>%
  mutate(height_above_msl = case_when(height_above_msl < groundElev ~ groundElev,
                                      TRUE ~ height_above_msl)) %>%
  ggplot(aes(x = timestamp, y = height_above_msl))+
  geom_area(aes(y = groundElev), fill = "#996633")+
  geom_line(alpha = 0.5)+
  geom_point(aes(col = ground_speed), size = 3)+
  scale_color_viridis_c()+
  ylab("Elevation (m)")+
  xlab("Time")+
  theme_minimal()+
  sunriseSunsetBars
altitude
```
## RST (RESIDENCE IN SPACE AND TIME)

I think it would be interesting to try this RST model (residence in space and time), described here: https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0168513#pone.0168513.ref019. This would be useful for classifying vulture "behavioral states," i.e. intensive searching, feeding, etc. I am not sure how well it will work, but I'm going to give it a shot with one individual's movement track. The code for the method is here: https://github.com/raorben/RST

Going to just try it with this one individual, 

```{r eval = FALSE}
# Prepare the data by converting it from lat/long to UTM.
trackForRST <- trackSF %>%
  dplyr::select(trackId, timestamp)
crsMeters <- 32636 # UTM projection to use, for Israel
trackForRST_converted <- trackForRST %>%
  sf::st_transform(crsMeters)
trackForRST_converted <- trackForRST_converted %>%
  cbind(., sf::st_coordinates(.)) %>%
  sf::st_drop_geometry()
dataset <- trackForRST_converted
dataset <- dataset %>%
  rename("datetime" = timestamp,
         "band" = trackId)
```

Calculate residence values:

```{r eval = FALSE}
# --------------------- CALCULATING RESIDENCE VALUES --------------------- #
# create a time array: duration of trip in given time units
time_units = "secs" # one of "secs", "mins", "hours", "days", "weeks"

# set the desired radius (km) and threshold values
# make sure this is in sequential order with no duplicate values
# radius should be chosen around the expected movement scale. Its is also helpful to increase the resolution of radii increments
# near where the proportion of transit points falls below 0.05. You will probably need to run this a couple of times to refine.
radius = c(seq(50, 200, by = 1))
threshold <- rep(0, length(radius))

# determine the different individuals
bandIDs <- unique(dataset$band) # XXX only have one individual here.

# for each track, calculate residence values
# If a track never leaves the chosen radius this will result in NAs for residence time, distance and residuals and an associated warning.

# For residence and residual calculations, NA are assigned to 
# (1) locations at the beginning of tracks until the animal moves beyond R from the initial point, 
# and (2) to those locations at the end that are all within R of the last radius built.

all_tracks = data.frame()
threshold <- 0
for (i in 1:length(bandIDs)) {
  subdata = dataset[dataset$band == bandIDs[i], ]
  
  subdata$time_diff = as.numeric(subdata$datetime - subdata$datetime[1], units = time_units) # calculates the time difference from this point to the beginning point.
  result <- residenceCalc(subdata$X, subdata$Y, subdata$time_diff, radius, threshold)
  subdata = cbind(subdata, result)
  all_tracks = rbind(all_tracks, subdata)
}


# Save results of all scales
MoveResid<-list(all_tracks, radius, threshold, time_units, bandIDs)
saveRDS(MoveResid,file = ("data/T61w_allscales.rda"))
#MoveResid<-readRDS("data/T61w_allscales.rda")
```

```{r eval = FALSE}
# --------------------- PLOTTING SCALE OF RESIDUALS & CHOOSING BEST ONE--------------------- #
pdf("data/T61w_MultiScale.pdf")
scales<-plotMultiScale1(all_tracks, radius, xmax = max(radius))
dev.off()

#for multiple tracks
#pdf("MultiScale.pdf")
#scalesum<-plotMultiScale(all_tracks, radius) 
#dev.off()

#if you don't choose radi large enough for the % transit points to be <0.05 then chooseDynScale will return an error
dynscale <- chooseDynScale(scales, radius) #animal/track ids must be numeric
write.csv(x = dynscale,file = "data/DynScaleResults.csv")
```
Even with enormous radius values, we are still not getting a value for scaling. It's possible this just won't work. Alternatively, I can go back to the paper and see if they explain what to do when this method fails.
Aaaand the paper does not say what to do if this value isn't obtainable. Consider either reaching out to them, or trying to figure out a priori what a reasonable transit speed value is for the vultures.

Well, Ruppell's Griffon Vulture has an average cruising speed of 22mph. 
https://blogs.bu.edu/bioaerial2012/2012/09/26/the-ruppells-griffon-vulture-the-highest-recorded-flying-bird/#:~:text=This%20vulture%20has%20an%20average,oxygen%20intake%20much%20more%20effective.
If we use 20mph for the griffon vulture transit speed, that's about 35 kph.

R = (35kph*0.166hours)/2 = radius of 2.9 km.

What happens if we just try using that radius?

Calculate residence values:

```{r eval = FALSE}
radius <- 2.9
all_tracks = data.frame()
threshold <- 0
for (i in 1:length(bandIDs)) {
  subdata = dataset[dataset$band == bandIDs[i], ]
  
  subdata$time_diff = as.numeric(subdata$datetime - subdata$datetime[1], units = time_units) # calculates the time difference from this point to the beginning point.
  result <- residenceCalc(subdata$X, subdata$Y, subdata$time_diff, radius, threshold)
  subdata = cbind(subdata, result)
  all_tracks = rbind(all_tracks, subdata)
}
```

```{r eval = FALSE}
# --------------------- PLOTTING TRACKS AND RESIDUALS --------------------- #
# The plotting functions below take the dataset with residence values and and a string naming the residual. To look at the full dataset, type "track = all_tracks". To "zoom in" on a section of the track, pass in the specific indeces.
all_tracks <- all_tracks %>%
  rename("lon" = X, "lat" = Y)

# This function plots the track contours, color-coded by both residence time and distance:
for (i in 1:length(radius)) {
  quartz()
  #windows()#for Windows users
  plotTrackContour(all_tracks, radius[i], threshold[i])
}

# This function plots the residual values and the track contour, color-coded by sign of residual:
for (i in 1:length(radius)) {
  quartz()
  #windows()#for Windows users
  plotTrackRes(all_tracks, radius[i], threshold[i], time_units)
}
```
Okay, this is promising. But I'm going to move away from it now and start looking at specific feeding events.

## FEEDING EVENTS

Read in the feeding event data
```{r}
feedEvents <- read.csv("data/feeding_station_south_data.xlsx - Sheet1.csv")
# add datetime
feedEvents <- feedEvents %>%
  mutate(datetime = lubridate::mdy_hms(Timestamp)) %>%
  dplyr::select(-Timestamp)

# Subset to only include feeding events that occurred within the time range of this dataset
min <- min(dat$timestamp)
max <- max(dat$timestamp)
feedEvents <- feedEvents %>%
  filter(datetime >= min & datetime <= max)
nrow(feedEvents)
head(feedEvents)
table(feedEvents$area)
```

Okay, now that we have that data, we critically need access to the feeding station data so that we can match these carcass drops to lat/long.

```{r}
feedingStations <- read.csv("data/feeding_station_south_coordinates.xlsx - Sheet1.csv")
head(feedingStations)

# Are we going to be able to join these by name? I am not optimistic...
feedEvents$feeding_station %in% feedingStations$Feeding_station # awesome!!! oh my gosh.

# okay, let's join the coordinates
feedEvents <- feedEvents %>%
  left_join(feedingStations %>%
              dplyr::select(Feeding_station, lat, long),
            by = c("feeding_station" = "Feeding_station")) %>%
  mutate(lat = as.numeric(lat),
         long = as.numeric(long))
  
head(feedEvents)


# Remove any missing values. Later, will need to ask Gideon why these coordinates are missing, and see what we can do about it. But for now, this is just a proof of concept.
feedEvents <- feedEvents %>%
  filter(!is.na(lat) & !is.na(long))

# Now make it an sf object
feedEvents <- feedEvents %>%
  sf::st_as_sf(., coords = c("long", "lat"), remove = FALSE) %>%
  sf::st_set_crs("WGS84") %>%
  dplyr::select(-c(death_of_carcass_known, hours_since_death, origin_carcass, ranger, remarks))
```

Do some preliminary plotting

```{r}
mask <- suppressMessages(sf::st_read("data/CutOffRegion.kml"))
datMasked <- vultureUtils::maskData(dataset = dat, mask = mask, longCol = "location_long.1", latCol = "location_lat.1", crs = "WGS84")
# Get bounding box
lon <- range(datMasked$location_long)
lat <- range(datMasked$location_lat)

map <- ggmap::get_stamenmap(bbox = c(lon[1], lat[1], lon[2], lat[2]), zoom = 7, maptype = "terrain-background")
map

test <- datMasked[1:100,] %>%
  sf::st_set_crs("WGS84")

# Get one individual
test <- datMasked %>%
  filter(trackId == "T61w")

# Get bounding box for this indiv
lon <- range(test$location_long)
lat <- range(test$location_lat)

map <- ggmap::get_stamenmap(bbox = c(lon[1], lat[1], lon[2], lat[2]), zoom = 10, maptype = "terrain-background")

# Make the map
ggmap(map)+
  geom_point(data = test, aes(x = location_long.1, y = location_lat.1, col = ground_speed), size = 0.2)+
  geom_path(data = test, aes(x = location_long.1, y = location_lat.1), size = 0.02)+
  scale_color_viridis_c()

# Let's now do this separately for different years
unique(lubridate::year(test$dateOnly))

t20 <- test %>%
  filter(lubridate::year(dateOnly) == 2020)
t21 <- test %>%
  filter(lubridate::year(dateOnly) == 2021)
t22 <- test %>%
  filter(lubridate::year(dateOnly) == 2022)

lon <- range(t20$location_long)
lat <- range(t20$location_lat)
map <- ggmap::get_stamenmap(bbox = c(lon[1], lat[1], lon[2], lat[2]), zoom = 10, maptype = "terrain-background")
ggmap(map)+
  geom_point(data = t20, aes(x = location_long.1, y = location_lat.1, col = ground_speed), size = 0.2)+
  geom_path(data = t20, aes(x = location_long.1, y = location_lat.1), size = 0.02)+
  scale_color_viridis_c()

lon <- range(t21$location_long)
lat <- range(t21$location_lat)
map <- ggmap::get_stamenmap(bbox = c(lon[1], lat[1], lon[2], lat[2]), zoom = 10, maptype = "terrain-background")
ggmap(map)+
  geom_point(data = t21, aes(x = location_long.1, y = location_lat.1, col = ground_speed), size = 0.2)+
  geom_path(data = t21, aes(x = location_long.1, y = location_lat.1), size = 0.02)+
  scale_color_viridis_c()

lon <- range(t22$location_long)
lat <- range(t22$location_lat)
map <- ggmap::get_stamenmap(bbox = c(lon[1], lat[1], lon[2], lat[2]), zoom = 10, maptype = "terrain-background")
ggmap(map)+
  geom_point(data = t22, aes(x = location_long.1, y = location_lat.1, col = ground_speed), size = 0.2)+
  geom_path(data = t22, aes(x = location_long.1, y = location_lat.1), size = 0.02)+
  scale_color_viridis_c()
```

Okay, now that I know how to plot points and I know when and where the feeding events have occurred, time to plot points around each feeding station, color-coded by individual, around the time of the feeding events.

```{r warning=F}
head(feedEvents)
# plot just the feeding events
feedEvents %>%
  ggplot(aes(x = long, y = lat, col = as.numeric(datetime)))+
  geom_point(size = 2)+
  scale_color_viridis_c()

# Let's pick the most recent feeding event to test with
event <- feedEvents %>%
  slice(1)

# Filter the data to just get the data 2 hours before up to 24 hours later than the feeding time.
thisEvent <- datMasked %>%
  filter(timestamp > event$datetime[1] - lubridate::as.duration("2 hours") & timestamp < event$datetime[1] + lubridate::as.duration("200 hours"))
nrow(thisEvent) # 925 points
length(unique(thisEvent$trackId)) # 26 individuals
# I have not yet restricted this spatially.

bbox <- bboxFromRad(lon = event$long, lat = event$lat, kmDist = 3)
map <- ggmap::get_stamenmap(bbox = bbox, zoom = 10, maptype = "terrain-background")
ggmap(map)+
  geom_point(data = thisEvent, aes(x = location_long.1, y = location_lat.1, col = trackId), size = 1)+
  #geom_path(data = thisEvent, aes(x = location_long.1, y = location_lat.1, col = trackId), size = 0.5)+
  geom_point(data = event, aes(x = long, y = lat), col = "black", size = 3)+
  scale_color_viridis_d()+
  theme(legend.position = "none")
```

I was going to try to animate this, but instead I'm just going to calculate distance over time and plot it. Duh.

```{r}
# Calculate distance from carcass over time
thisEvent <- thisEvent %>%
  mutate(distanceFromCarcass = as.numeric(sf::st_distance(., event))/1000)

# Plot distance from carcass over time
thisEvent %>%
  ggplot(aes(x = timestamp, y = distanceFromCarcass, col = trackId))+
  geom_point()+
  geom_line()+
  geom_vline(aes(xintercept = event$datetime[1]))+
  theme_minimal()+
  ylim(0, 100)
```

Now I want to do this for all feeding events.
```{r}
# Make a list of the datasets for each feeding event, ranging from 2 hours before carcass placement through 200 hours after carcass placement. For each point in the dataset, calculate the distance from the carcass.
eventsList <- feedEvents %>%
  group_by(datetime) %>%
  group_split(.keep = T)
length(eventsList)

eventsDat <- lapply(eventsList, function(x){
  dat <- datMasked %>%
    filter(timestamp > x$datetime[1]-lubridate::as.duration("2 hours") & timestamp < x$datetime[1] + lubridate::as.duration("100 hours")) %>%
    mutate(timeSinceCarcassPlaced = timestamp - x$datetime[1])
})

eventsDat <- map2(.x = eventsDat, .y = eventsList, .f = function(.x, .y){
  .x <- .x %>%
    mutate(distanceFromCarcass = as.numeric(sf::st_distance(., .y))/1000)
})

# download elevation rasters for points within 3km of each feeding event
eventsDat3km <- lapply(eventsDat, function(x){
  x %>%
    filter(distanceFromCarcass < 3)
})

elevRasters <- lapply(eventsDat3km, function(x){
  if(nrow(x) == 0){
    return(NULL)
  }else{
    elev <- elevatr::get_elev_raster(x, z = 12)
    return(elev)
  }
})

# add elevation information to data frames, but only for the points within 3km of the feeding site.
eventsDat <- map2(.x = eventsDat, .y = elevRasters, .f = function(.x, .y){
  if(is.null(.y)){
    .x <- .x %>%
      mutate(groundElev = NA,
             height_above_ground = NA)
  }else{
    .x <- .x %>%
      mutate(groundElev = raster::extract(.y, .x),
             height_above_ground = height_above_msl - groundElev) %>%
      mutate(height_above_ground = case_when(height_above_ground < 0 ~ 0,
                                             TRUE ~ height_above_ground))
  }
})

# Now we can use this to make the same plot for each feeding event, limiting it to a certain radius
plots <- map2(.x = eventsDat, .y = eventsList, .f = function(.x, .y){
  p <- .x %>%
  ggplot(aes(x = timestamp, y = distanceFromCarcass, col = trackId))+
  geom_point()+
  geom_line()+
  geom_vline(aes(xintercept = .y$datetime[1]))+
  theme_minimal()+
  ylim(0, 20)
})
plots
```

Okay, let's visualize some things:
1. Define "detection" as a vulture passing within 1km of the site, regardless of speed or altitude.
2. Define "arrival" as being within 0.25km with a ground speed < 5m/s and an elevation < 10m

### Calculate detections and arrivals for each bird at each carcass
```{r}
eventsDat <- lapply(eventsDat, function(x){
  x <- x %>%
    mutate(detection = case_when(distanceFromCarcass < 1 & 
                                   timeSinceCarcassPlaced > 0  ~ TRUE,
                                 TRUE ~ FALSE),
           visit = case_when(distanceFromCarcass < 0.25 & ground_speed < 5 & 
                               !is.na(height_above_ground) & height_above_ground < 10 &
                               timeSinceCarcassPlaced > 0 ~ 
                               TRUE,
                             TRUE ~ FALSE))
})
```

### Time to first contact (all carcasses--histogram)
```{r}
allCarcasses <- data.table::rbindlist(eventsDat, idcol = "eventID") %>%
  as.data.frame() %>%
  dplyr::select(eventID, ground_speed, height_above_msl, location_lat, location_long, timestamp, dateOnly, trackId, geometry, timeSinceCarcassPlaced, distanceFromCarcass, groundElev, height_above_ground, detection, visit)
```

#### Time to first detection
Let's assume that all carcasses will be detected within 10 days = 240 hours = 14400 minutes. So we'll filter the data down to that.
```{r}
firstDetections <- allCarcasses %>%
  filter(timeSinceCarcassPlaced > 0 & timeSinceCarcassPlaced < 14400, detection == TRUE) %>%
  group_by(eventID) %>%
  arrange(timestamp, .by_group = TRUE) %>%
  slice(1)
glimpse(firstDetections)

firstDetections %>%
  ggplot(aes(x = as.numeric(timeSinceCarcassPlaced)/60))+
  geom_density(fill = "lightblue", col = "lightblue")+
  geom_vline(aes(xintercept = 24), col = "darkblue", alpha = 0.7)+
  geom_vline(aes(xintercept = 48), col = "darkblue", alpha = 0.5)+
  geom_vline(aes(xintercept = 72), col = "darkblue", alpha = 0.3)+
  geom_vline(aes(xintercept = 96), col = "darkblue", alpha = 0.1)+
  theme_classic()+
  ylab("Frequency")+
  xlab("Time to first detection (hours)")
```

#### Time to first visit
```{r}
firstVisits <- allCarcasses %>%
  filter(timeSinceCarcassPlaced > 0 & timeSinceCarcassPlaced < 14400, visit == TRUE) %>%
  group_by(eventID) %>%
  arrange(timestamp, .by_group = TRUE) %>%
  slice(1)
glimpse(firstVisits)

firstVisits %>%
  ggplot(aes(x = as.numeric(timeSinceCarcassPlaced)/60))+
  geom_density(fill = "#FCA18E", col = "#FCA18E")+
  geom_vline(aes(xintercept = 24), col = "darkred", alpha = 0.7)+
  geom_vline(aes(xintercept = 48), col = "darkred", alpha = 0.5)+
  geom_vline(aes(xintercept = 72), col = "darkred", alpha = 0.3)+
  geom_vline(aes(xintercept = 96), col = "darkred", alpha = 0.1)+
  theme_classic()+
  ylab("Frequency")+
  xlab("Time to first visit (hours)")
```
This looks very similar to the first detection graph.
Let's plot them against each other:

```{r}
df <- firstDetections %>%
  mutate(type = "detection") %>%
  bind_rows(firstVisits %>%
              mutate(type = "visit")) %>%
  dplyr::select(eventID, timeSinceCarcassPlaced, type) %>%
  pivot_wider(id_cols = eventID, values_from = timeSinceCarcassPlaced, names_from = type) %>%
  mutate(visitLag = visit-detection)

df %>%
  filter(detection < 7500) %>%
  filter(!is.na(detection) & !is.na(visit)) %>%
  ggplot(aes(x = detection, y = visit))+
  geom_point(size = 2)+
  theme_classic()+
  geom_smooth(method = "lm") # ok this is not intuitive... would think there would be a very straightforward relationship between first detection and first visit.

# Oh no, wait, is detection always earlier than visit?
df$visit >= df$detection # always greater than or equal, by definition (because a visit also counts as a detection).
df$visit == df$detection # there are some where the first detection is the same as the first visit.
summary(as.numeric(df$visitLag)) # yeah, several of the visitLags are 0, which is another way of saying the same thing.

# Do later-detected carcasses take longer to be visited after detection?
head(df)
df %>%
  filter(detection < 7500) %>%
  filter(!is.na(detection) & !is.na(visitLag)) %>%
  ggplot(aes(x = detection, y = visitLag))+
  geom_point()+
  theme_classic()+
  geom_smooth(method = "lm")+ # no relationship.
# But what if we remove the ones where visitLag is 0?
  geom_smooth(data = df %>%
                filter(detection < 7500, !is.na(detection), !is.na(visitLag), visitLag > 0),
              aes(x = detection, y = visitLag), method = "lm", col = "red")
# Still no significant relationship. Need to repeat this analysis with more carcass data.
```

### First visit times for each bird at each carcass

Group by carcass and individual to get each bird's first visit
```{r}
df <- allCarcasses %>%
  group_by(eventID, trackId) %>%
  filter(visit == TRUE) %>%
  arrange(timestamp, .by_group = TRUE) %>%
  slice(1) 
  
head(df)

df <- df %>%
  group_by(eventID) %>%
  arrange(timestamp, .by_group = T) %>%
  mutate(nFirstVisits = 1:n())

# Make some curves
df %>%
  ggplot(aes(x = as.numeric(timeSinceCarcassPlaced)/60, y = nFirstVisits, col = as.factor(eventID)))+       geom_line()+
  theme_classic()+
  theme(legend.position = "none")+
  ylab("Number of unique vultures that have visited")+
  xlab("Time since carcass placement (hours)")

# Aha, this isn't informative because it includes a bunch of days.
# We need the time extent to be really long because it needs to allow for a long period of time between placement and first detection. But that's not actually the x axis. Need to be plotting time since first overall visit detection vs. # of vultures that have made first visits.
head(df)

df <- df %>%
  group_by(eventID) %>%
  arrange(timestamp, .by_group = TRUE) %>%
  mutate(timeSinceFirstVisit = timestamp-timestamp[1])

df %>%
  filter(as.numeric(timeSinceFirstVisit)/3600 < 48) %>%
  ggplot(aes(x = as.numeric(timeSinceFirstVisit)/3600, y = nFirstVisits, col = as.factor(eventID)))+       geom_line()+
  theme_classic()+
  theme(legend.position = "none")+
  ylab("Number of unique vultures that have visited")+
  xlab("Time since the first vulture first visited (hours)")
```
Really really need information about the following:
1. How long does a carcass stick around once it's placed?
2. How often are new carcasses deposited at the same feeding site? (I can actually get this information myself, by analyzing the data differently, i.e. overlaying the carcass placements with the entire time series instead of subsetting the data separately for each carcass.)

### Over time, # vultures within each distance band (0-1, 0-5, 0-10) etc. colored by band

```{r}
allCarcasses <- allCarcasses %>%
  filter(timeSinceCarcassPlaced > 0) %>%
  mutate(hour = lubridate::floor_date(timestamp, unit = "hour")) %>%
  mutate(under1 = distanceFromCarcass < 1,
         under5 = distanceFromCarcass < 5,
         under10 = distanceFromCarcass < 10,
         under50 = distanceFromCarcass < 50,
         under100 = distanceFromCarcass < 100,
         over100 = distanceFromCarcass > 100)

summ <- allCarcasses %>%
  dplyr::select(eventID, trackId, hour, under1, under5, under10, under50, under100, over100) %>%
  distinct() %>%
  pivot_longer(cols = -c("eventID", "trackId", "hour"), names_to = "thresh", values_to = "val") %>%
  filter(val == TRUE) %>%
  dplyr::select(-val) %>%
  group_by(eventID, hour, thresh) %>%
  summarize(n = n())

eventSumms <- summ %>%
  ungroup() %>%
  group_by(eventID) %>%
  group_split(.keep = T)
plots <- lapply(eventSumms, function(x){
  p <- x %>%
  mutate(thresh = factor(thresh, levels = c("under1", "under5", "under10", "under50", "under100", "over100"))) %>%
  ggplot(aes(x = hour, y = n, col = thresh))+
  geom_point()+
  geom_line()+
  theme_classic()
  return(p)
})
```


### for each carcass, # visits each hour.
- this may help us determine depletion.
### For each vulture, number of visits to the carcass (until its depletion) (within a certain window)


