---
title: "Sandbox"
author: "Kaija Gahm"
date: "2022-10-04"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(vultureUtils)
library(move)
library(igraph)
library(elevatr) # for getting elevation data
library(suncalc) # for calculating sunrise and sunset
```

Download some data from 2020-present to mess around with
```{r}
base::load("movebankCredentials/pw.Rda")
MB.LoginObject <- movebankLogin(username = 'kaijagahm', password = pw)
rm(pw)

#dat <- vultureUtils::downloadVultures(loginObject = MB.LoginObject, removeDup = T, dfConvert = T, quiet = T)
#save(dat, file = "data/dat.Rda")
base::load("data/dat.Rda")
```

Let's look at the presence of the vultures over time.

```{r}
unique(dat$trackId)
dates <- dat %>%
  dplyr::select(trackId, dateOnly) %>%
  distinct()

dates %>%
  ggplot(aes(x = trackId, y = dateOnly))+
  geom_point(size = 0.2)+
  coord_flip()
```
Now I'd like to annotate this data with periods to remove
```{r}
toRemove <- read.csv("data/whoswho_vultures11Jul22_new.xlsx - periods_to_remove.csv") %>%
  mutate(across(everything(), .fns = function(x){str_replace_all(x, pattern = "\t", replacement = "")}))
head(toRemove)
toRemove <- toRemove %>%
  dplyr::select("trackId" = Movebank_id,
                remove_start,
                remove_end,
                reason) %>%
  mutate(remove_start = stringr::str_remove(remove_start, pattern = ".*day, "),
         remove_end = stringr::str_remove(remove_end, pattern = ".*day, ")) %>%
  mutate(across(c(remove_start, remove_end), .fns = function(x){
    as.Date(lubridate::parse_date_time2(x, orders = c("%B%d%Y", "%Y%m%d")))
  })) %>%
  dplyr::filter(!is.na(remove_end))

toRemove_long <- toRemove %>%
  group_by(trackId, reason) %>%
  # sequence of daily dates for each corresponding start, end elements
  dplyr::mutate(dateOnly = map2(remove_start, remove_end, seq, by = "1 day")) %>%
  # unnest the list column
  unnest(cols = c(dateOnly)) %>% 
  # remove any duplicate rows
  distinct() %>%
  dplyr::select(-c(remove_start, remove_end)) %>%
  rename("status" = reason)

# Join to the original data
datAnnot <- dat %>%
  left_join(toRemove_long, by = c("trackId", "dateOnly")) %>%
  mutate(status = replace_na(status, "valid"))

# Plot, coloring by the vulture status
datAnnot %>%
  dplyr::select(trackId, dateOnly, status) %>%
  distinct() %>%
  ggplot(aes(x = trackId, y = dateOnly, col = status))+
  geom_point(size = 0.2)+
  coord_flip()+
  guides(col = guide_legend(override.aes = list(size = 10)))+
  scale_color_viridis_d()

# Try again, just removing the invalid data.
datAnnot %>%
  filter(status == "valid") %>%
  dplyr::select(trackId, dateOnly) %>%
  distinct() %>%
  ggplot(aes(x = trackId, y = dateOnly))+
  geom_point(size = 0.2)+
  coord_flip()

# Now we can sort by a couple different things
## Compute start date, end date, and longest consecutive run.
metrics <- datAnnot %>%
  filter(status == "valid") %>%
  dplyr::select(trackId, dateOnly) %>%
  distinct() %>%
  group_by(trackId) %>%
  group_by(cumsum(c(0, diff(dateOnly) - 1))) %>%
  mutate(consecLen = n()) %>%
  ungroup() %>%
  group_by(trackId) %>%
  summarize(startDate = min(dateOnly),
            endDate = max(dateOnly),
            longestRun = max(consecLen))

datAnnot <- datAnnot %>%
  left_join(metrics, by = "trackId")

# Plot, sorting by earliest start date
datAnnot %>%
  filter(status == "valid") %>%
  mutate(trackId = forcats::fct_reorder(trackId, startDate, .desc = T)) %>%
  dplyr::select(trackId, dateOnly) %>%
  distinct() %>%
  ggplot(aes(x = trackId, y = dateOnly))+
  geom_point(size = 0.2)+
  coord_flip()

# Plot, sorting by earliest end date
datAnnot %>%
  filter(status == "valid") %>%
  mutate(trackId = forcats::fct_reorder(trackId, endDate, .desc = T)) %>%
  dplyr::select(trackId, dateOnly) %>%
  distinct() %>%
  ggplot(aes(x = trackId, y = dateOnly))+
  geom_point(size = 0.2)+
  coord_flip()

# Plot, sorting by longest run
datAnnot %>%
  filter(status == "valid") %>%
  mutate(trackId = forcats::fct_reorder(trackId, longestRun)) %>%
  dplyr::select(trackId, dateOnly) %>%
  distinct() %>%
  ggplot(aes(x = trackId, y = dateOnly))+
  geom_point(size = 0.2)+
  coord_flip()
```
Okay, in order to get more complete mortality data, I'm going to need to add on the INPA data.

## Arrival at carcasses

Let's move on to examining an individual's movement patterns to identify arrival at a carcass site.
Going to pick the individual with the longest run
```{r}
targetIndiv <- datAnnot %>%
  arrange(-longestRun) %>%
  slice(1) %>%
  pull(trackId)

track <- datAnnot %>%
  filter(trackId == targetIndiv)

trackDays <- track %>%
  group_by(dateOnly) %>%
  group_split(.keep = TRUE)
```

Visualize acceleration
```{r}
acc <- track %>%
  dplyr::select(dateOnly, timestamp, contains("acceleration_")) %>%
  pivot_longer(cols = contains("acceleration_"), names_to = "axis", values_to = "acceleration") %>%
  mutate(axis = str_remove(axis, "acceleration_raw_"))

acc %>%
  ggplot(aes(x = timestamp, y = acceleration, col = axis))+
  geom_line()
```
Okay, that's not very informative, as expected. Let's split this by day and just look at one day's sequence.

```{r}
accDays <- lapply(trackDays, function(x){
  x %>% dplyr::select(dateOnly, timestamp, contains("acceleration_")) %>%
    pivot_longer(cols = contains("acceleration_"), names_to = "axis", values_to = "acceleration") %>%
    mutate(axis = str_remove(axis, "acceleration_raw_"))
})
```

```{r}
randomDay <- sample(1:length(accDays), size = 1)

accDays[[randomDay]] %>%
  ggplot(aes(x = timestamp, y = acceleration, col = axis))+
  geom_line()
```
Okay, this is kind of cool. But I'm not good enough at interpreting accelerometer data to know for sure how to read this.

What about speed and altitude? Can the combination of those tell us what we need to know?
```{r}
randomDay <- sample(1:length(accDays), size = 1)
speed <- trackDays[[randomDay]] %>%
  ggplot(aes(x = timestamp, y = ground_speed))+
  geom_line()
speed

altitude <- trackDays[[randomDay]] %>%
  ggplot(aes(x = timestamp, y = height_above_msl))+
  geom_line()
altitude
```

In order for this to make any sense at all, we need to cross-reference these measurements with elevation data for Israel. We can obtain this using the `elevatr` package.

```{r}
# Add sunrise and sunset information using suncalc
## first let's get the mean lat and long for the current track
meanLat <- mean(track$location_lat)
meanLong <- mean(track$location_long)
dates <- seq(from = min(track$dateOnly), to = max(track$dateOnly), by = "1 day")
sunriseSunset <- suncalc::getSunlightTimes(date = dates, lat = meanLat, lon = meanLong, keep = c("sunrise", "sunset")) %>%
  dplyr::select("dateOnly" = date, sunrise, sunset)
track <- track %>%
  left_join(sunriseSunset, by = "dateOnly")

# Make it an sf object and add elevation
trackSF <- track %>%
  sf::st_as_sf(., coords = c("location_long", "location_lat"), crs = "WGS84")
elevs <- elevatr::get_elev_raster(trackSF, z = 14) # this is the max zoom level. It's between 4m and 10m resolution.
trackSF$groundElev <- raster::extract(x = elevs, y = trackSF)
trackSF <- trackSF %>%
  mutate(height_above_ground = height_above_msl - groundElev)

# let's set anything below 0 to 0.
trackSF <- trackSF %>%
  mutate(height_above_ground = case_when(height_above_ground < 0 ~ 0,
                                         TRUE ~ height_above_ground))

trackDaysSF <- trackSF %>%
  group_by(dateOnly) %>%
  group_split(.keep = TRUE)
```

Now let's re-do the speed and altitude plots, using altitude above ground:
```{r}
# create rectangles to add to ggplot, assuming the dataset has the "sunrise" and "sunset" and "timestamp" columns.
sunriseSunsetBars <- list(geom_rect(aes(xmin = min(timestamp),
                xmax = min(sunrise),
                ymin = -Inf,
                ymax = Inf), alpha = 0.003),
                geom_rect(aes(xmin = max(sunset),
                xmax = max(timestamp),
                ymin = -Inf,
                ymax = Inf), alpha = 0.003))

randomDay <- sample(1:length(trackDaysSF), size = 1)

altitude <- trackDaysSF[[randomDay]] %>%
  mutate(height_above_msl = case_when(height_above_msl < groundElev ~ groundElev,
                                      TRUE ~ height_above_msl)) %>%
  ggplot(aes(x = timestamp, y = height_above_msl))+
  geom_area(aes(y = groundElev), fill = "#996633")+
  geom_line(alpha = 0.5)+
  geom_point(aes(col = ground_speed), size = 3)+
  scale_color_viridis_c()+
  ylab("Elevation (m)")+
  xlab("Time")+
  theme_minimal()+
  sunriseSunsetBars
altitude
```

I think it would be interesting to try this RST model (residence in space and time), described here: https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0168513#pone.0168513.ref019. This would be useful for classifying vulture "behavioral states," i.e. intensive searching, feeding, etc. I am not sure how well it will work, but I'm going to give it a shot with one individual's movement track. The code for the method is here: https://github.com/raorben/RST

```{r}

```


