---
title: "Sandbox"
author: "Kaija Gahm"
date: "2022-10-04"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(vultureUtils)
library(move)
library(igraph)
library(elevatr) # for getting elevation data
library(suncalc) # for calculating sunrise and sunset
source("RST_functions_all.R")
dyn.load("RST_residenceRadii.so")
library(ggmap)
source("bboxFromRad.R")
```

Download some data from 2020-present to mess around with
```{r}
base::load("movebankCredentials/pw.Rda")
MB.LoginObject <- movebankLogin(username = 'kaijagahm', password = pw)
rm(pw)

#dat <- vultureUtils::downloadVultures(loginObject = MB.LoginObject, removeDup = T, dfConvert = T, quiet = T)
#save(dat, file = "data/dat.Rda")
base::load("data/dat.Rda")
```

Let's look at the presence of the vultures over time.

```{r}
unique(dat$trackId)
dates <- dat %>%
  dplyr::select(trackId, dateOnly) %>%
  distinct()

dates %>%
  ggplot(aes(x = trackId, y = dateOnly))+
  geom_point(size = 0.2)+
  coord_flip()
```
Now I'd like to annotate this data with periods to remove
```{r}
toRemove <- read.csv("data/whoswho_vultures11Jul22_new.xlsx - periods_to_remove.csv") %>%
  mutate(across(everything(), .fns = function(x){str_replace_all(x, pattern = "\t", replacement = "")}))
head(toRemove)
toRemove <- toRemove %>%
  dplyr::select("trackId" = Movebank_id,
                remove_start,
                remove_end,
                reason) %>%
  mutate(remove_start = stringr::str_remove(remove_start, pattern = ".*day, "),
         remove_end = stringr::str_remove(remove_end, pattern = ".*day, ")) %>%
  mutate(across(c(remove_start, remove_end), .fns = function(x){
    as.Date(lubridate::parse_date_time2(x, orders = c("%B%d%Y", "%Y%m%d")))
  })) %>%
  dplyr::filter(!is.na(remove_end))

toRemove_long <- toRemove %>%
  group_by(trackId, reason) %>%
  # sequence of daily dates for each corresponding start, end elements
  dplyr::mutate(dateOnly = map2(remove_start, remove_end, seq, by = "1 day")) %>%
  # unnest the list column
  unnest(cols = c(dateOnly)) %>% 
  # remove any duplicate rows
  distinct() %>%
  dplyr::select(-c(remove_start, remove_end)) %>%
  rename("status" = reason)

# Join to the original data
datAnnot <- dat %>%
  left_join(toRemove_long, by = c("trackId", "dateOnly")) %>%
  mutate(status = replace_na(status, "valid"))

# Plot, coloring by the vulture status
datAnnot %>%
  dplyr::select(trackId, dateOnly, status) %>%
  distinct() %>%
  ggplot(aes(x = trackId, y = dateOnly, col = status))+
  geom_point(size = 0.2)+
  coord_flip()+
  guides(col = guide_legend(override.aes = list(size = 10)))+
  scale_color_viridis_d()

# Try again, just removing the invalid data.
datAnnot %>%
  filter(status == "valid") %>%
  dplyr::select(trackId, dateOnly) %>%
  distinct() %>%
  ggplot(aes(x = trackId, y = dateOnly))+
  geom_point(size = 0.2)+
  coord_flip()

# Now we can sort by a couple different things
## Compute start date, end date, and longest consecutive run.
metrics <- datAnnot %>%
  filter(status == "valid") %>%
  dplyr::select(trackId, dateOnly) %>%
  distinct() %>%
  group_by(trackId) %>%
  group_by(cumsum(c(0, diff(dateOnly) - 1))) %>%
  mutate(consecLen = n()) %>%
  ungroup() %>%
  group_by(trackId) %>%
  summarize(startDate = min(dateOnly),
            endDate = max(dateOnly),
            longestRun = max(consecLen))

datAnnot <- datAnnot %>%
  left_join(metrics, by = "trackId")

# Plot, sorting by earliest start date
datAnnot %>%
  filter(status == "valid") %>%
  mutate(trackId = forcats::fct_reorder(trackId, startDate, .desc = T)) %>%
  dplyr::select(trackId, dateOnly) %>%
  distinct() %>%
  ggplot(aes(x = trackId, y = dateOnly))+
  geom_point(size = 0.2)+
  coord_flip()

# Plot, sorting by earliest end date
datAnnot %>%
  filter(status == "valid") %>%
  mutate(trackId = forcats::fct_reorder(trackId, endDate, .desc = T)) %>%
  dplyr::select(trackId, dateOnly) %>%
  distinct() %>%
  ggplot(aes(x = trackId, y = dateOnly))+
  geom_point(size = 0.2)+
  coord_flip()

# Plot, sorting by longest run
datAnnot %>%
  filter(status == "valid") %>%
  mutate(trackId = forcats::fct_reorder(trackId, longestRun)) %>%
  dplyr::select(trackId, dateOnly) %>%
  distinct() %>%
  ggplot(aes(x = trackId, y = dateOnly))+
  geom_point(size = 0.2)+
  coord_flip()
```
Okay, in order to get more complete mortality data, I'm going to need to add on the INPA data.

## Arrival at carcasses

Let's move on to examining an individual's movement patterns to identify arrival at a carcass site.
Going to pick the individual with the longest run
```{r}
targetIndiv <- datAnnot %>%
  dplyr::select(trackId, longestRun) %>%
  distinct() %>%
  arrange(-longestRun) %>%
  slice(1) %>%
  pull(trackId)

track <- datAnnot %>%
  filter(trackId == targetIndiv)

trackDays <- track %>%
  group_by(dateOnly) %>%
  group_split(.keep = TRUE)
```

Visualize acceleration
```{r}
acc <- track %>%
  dplyr::select(dateOnly, timestamp, contains("acceleration_")) %>%
  pivot_longer(cols = contains("acceleration_"), names_to = "axis", values_to = "acceleration") %>%
  mutate(axis = str_remove(axis, "acceleration_raw_"))

acc %>%
  ggplot(aes(x = timestamp, y = acceleration, col = axis))+
  geom_line()
```
Okay, that's not very informative, as expected. Let's split this by day and just look at one day's sequence.

```{r}
accDays <- lapply(trackDays, function(x){
  x %>% dplyr::select(dateOnly, timestamp, contains("acceleration_")) %>%
    pivot_longer(cols = contains("acceleration_"), names_to = "axis", values_to = "acceleration") %>%
    mutate(axis = str_remove(axis, "acceleration_raw_"))
})
```

```{r}
randomDay <- sample(1:length(accDays), size = 1)

accDays[[randomDay]] %>%
  ggplot(aes(x = timestamp, y = acceleration, col = axis))+
  geom_line()
```
Okay, this is kind of cool. But I'm not good enough at interpreting accelerometer data to know for sure how to read this.

What about speed and altitude? Can the combination of those tell us what we need to know?
```{r}
randomDay <- sample(1:length(accDays), size = 1)
speed <- trackDays[[randomDay]] %>%
  ggplot(aes(x = timestamp, y = ground_speed))+
  geom_line()
speed

altitude <- trackDays[[randomDay]] %>%
  ggplot(aes(x = timestamp, y = height_above_msl))+
  geom_line()
altitude
```

In order for this to make any sense at all, we need to cross-reference these measurements with elevation data for Israel. We can obtain this using the `elevatr` package.

```{r}
# Add sunrise and sunset information using suncalc
## first let's get the mean lat and long for the current track
meanLat <- mean(track$location_lat)
meanLong <- mean(track$location_long)
dates <- seq(from = min(track$dateOnly), to = max(track$dateOnly), by = "1 day")
sunriseSunset <- suncalc::getSunlightTimes(date = dates, lat = meanLat, lon = meanLong, keep = c("sunrise", "sunset")) %>%
  dplyr::select("dateOnly" = date, sunrise, sunset)
track <- track %>%
  left_join(sunriseSunset, by = "dateOnly")

# Make it an sf object and add elevation
trackSF <- track %>%
  sf::st_as_sf(., coords = c("location_long", "location_lat"), crs = "WGS84")
elevs <- elevatr::get_elev_raster(trackSF, z = 12) 
trackSF$groundElev <- raster::extract(x = elevs, y = trackSF)
trackSF <- trackSF %>%
  mutate(height_above_ground = height_above_msl - groundElev)

# let's set anything below 0 to 0.
trackSF <- trackSF %>%
  mutate(height_above_ground = case_when(height_above_ground < 0 ~ 0,
                                         TRUE ~ height_above_ground))

trackDaysSF <- trackSF %>%
  group_by(dateOnly) %>%
  group_split(.keep = TRUE)
```

Now let's re-do the speed and altitude plots, using altitude above ground:
```{r}
# create rectangles to add to ggplot, assuming the dataset has the "sunrise" and "sunset" and "timestamp" columns.
sunriseSunsetBars <- list(geom_rect(aes(xmin = min(timestamp),
                                        xmax = min(sunrise),
                                        ymin = -Inf,
                                        ymax = Inf), alpha = 0.003),
                          geom_rect(aes(xmin = max(sunset),
                                        xmax = max(timestamp),
                                        ymin = -Inf,
                                        ymax = Inf), alpha = 0.003))

randomDay <- sample(1:length(trackDaysSF), size = 1)

altitude <- trackDaysSF[[randomDay]] %>%
  mutate(height_above_msl = case_when(height_above_msl < groundElev ~ groundElev,
                                      TRUE ~ height_above_msl)) %>%
  ggplot(aes(x = timestamp, y = height_above_msl))+
  geom_area(aes(y = groundElev), fill = "#996633")+
  geom_line(alpha = 0.5)+
  geom_point(aes(col = ground_speed), size = 3)+
  scale_color_viridis_c()+
  ylab("Elevation (m)")+
  xlab("Time")+
  theme_minimal()+
  sunriseSunsetBars
altitude
```
## RST (RESIDENCE IN SPACE AND TIME)

I think it would be interesting to try this RST model (residence in space and time), described here: https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0168513#pone.0168513.ref019. This would be useful for classifying vulture "behavioral states," i.e. intensive searching, feeding, etc. I am not sure how well it will work, but I'm going to give it a shot with one individual's movement track. The code for the method is here: https://github.com/raorben/RST

Going to just try it with this one individual, 

```{r}
# Prepare the data by converting it from lat/long to UTM.
trackForRST <- trackSF %>%
  dplyr::select(trackId, timestamp)
crsMeters <- 32636 # UTM projection to use, for Israel
trackForRST_converted <- trackForRST %>%
  sf::st_transform(crsMeters)
trackForRST_converted <- trackForRST_converted %>%
  cbind(., sf::st_coordinates(.)) %>%
  sf::st_drop_geometry()
dataset <- trackForRST_converted
dataset <- dataset %>%
  rename("datetime" = timestamp,
         "band" = trackId)
```

Calculate residence values:

```{r}
# --------------------- CALCULATING RESIDENCE VALUES --------------------- #
# create a time array: duration of trip in given time units
time_units = "secs" # one of "secs", "mins", "hours", "days", "weeks"

# set the desired radius (km) and threshold values
# make sure this is in sequential order with no duplicate values
# radius should be chosen around the expected movement scale. Its is also helpful to increase the resolution of radii increments
# near where the proportion of transit points falls below 0.05. You will probably need to run this a couple of times to refine.
radius = c(seq(50, 200, by = 1))
threshold <- rep(0, length(radius))

# determine the different individuals
bandIDs <- unique(dataset$band) # XXX only have one individual here.

# for each track, calculate residence values
# If a track never leaves the chosen radius this will result in NAs for residence time, distance and residuals and an associated warning.

# For residence and residual calculations, NA are assigned to 
# (1) locations at the beginning of tracks until the animal moves beyond R from the initial point, 
# and (2) to those locations at the end that are all within R of the last radius built.

all_tracks = data.frame()
threshold <- 0
for (i in 1:length(bandIDs)) {
  subdata = dataset[dataset$band == bandIDs[i], ]
  
  subdata$time_diff = as.numeric(subdata$datetime - subdata$datetime[1], units = time_units) # calculates the time difference from this point to the beginning point.
  result <- residenceCalc(subdata$X, subdata$Y, subdata$time_diff, radius, threshold)
  subdata = cbind(subdata, result)
  all_tracks = rbind(all_tracks, subdata)
}


# Save results of all scales
MoveResid<-list(all_tracks, radius, threshold, time_units, bandIDs)
saveRDS(MoveResid,file = ("data/T61w_allscales.rda"))
#MoveResid<-readRDS("data/T61w_allscales.rda")
```

```{r}
# --------------------- PLOTTING SCALE OF RESIDUALS & CHOOSING BEST ONE--------------------- #
pdf("data/T61w_MultiScale.pdf")
scales<-plotMultiScale1(all_tracks, radius, xmax = max(radius))
dev.off()

#for multiple tracks
#pdf("MultiScale.pdf")
#scalesum<-plotMultiScale(all_tracks, radius) 
#dev.off()

#if you don't choose radi large enough for the % transit points to be <0.05 then chooseDynScale will return an error
dynscale <- chooseDynScale(scales, radius) #animal/track ids must be numeric
write.csv(x = dynscale,file = "data/DynScaleResults.csv")
```
Even with enormous radius values, we are still not getting a value for scaling. It's possible this just won't work. Alternatively, I can go back to the paper and see if they explain what to do when this method fails.
Aaaand the paper does not say what to do if this value isn't obtainable. Consider either reaching out to them, or trying to figure out a priori what a reasonable transit speed value is for the vultures.

Well, Ruppell's Griffon Vulture has an average cruising speed of 22mph. 
https://blogs.bu.edu/bioaerial2012/2012/09/26/the-ruppells-griffon-vulture-the-highest-recorded-flying-bird/#:~:text=This%20vulture%20has%20an%20average,oxygen%20intake%20much%20more%20effective.
If we use 20mph for the griffon vulture transit speed, that's about 35 kph.

R = (35kph*0.166hours)/2 = radius of 2.9 km.

What happens if we just try using that radius?

Calculate residence values:

```{r}
radius <- 2.9
all_tracks = data.frame()
threshold <- 0
for (i in 1:length(bandIDs)) {
  subdata = dataset[dataset$band == bandIDs[i], ]
  
  subdata$time_diff = as.numeric(subdata$datetime - subdata$datetime[1], units = time_units) # calculates the time difference from this point to the beginning point.
  result <- residenceCalc(subdata$X, subdata$Y, subdata$time_diff, radius, threshold)
  subdata = cbind(subdata, result)
  all_tracks = rbind(all_tracks, subdata)
}
```

```{r}
# --------------------- PLOTTING TRACKS AND RESIDUALS --------------------- #
# The plotting functions below take the dataset with residence values and and a string naming the residual. To look at the full dataset, type "track = all_tracks". To "zoom in" on a section of the track, pass in the specific indeces.
all_tracks <- all_tracks %>%
  rename("lon" = X, "lat" = Y)

# This function plots the track contours, color-coded by both residence time and distance:
for (i in 1:length(radius)) {
  quartz()
  #windows()#for Windows users
  plotTrackContour(all_tracks, radius[i], threshold[i])
}

# This function plots the residual values and the track contour, color-coded by sign of residual:
for (i in 1:length(radius)) {
  quartz()
  #windows()#for Windows users
  plotTrackRes(all_tracks, radius[i], threshold[i], time_units)
}
```
Okay, this is promising. But I'm going to move away from it now and start looking at specific feeding events.

## FEEDING EVENTS

Read in the feeding event data
```{r}
feedEvents <- read.csv("data/feeding_station_south_data.xlsx - Sheet1.csv")
# add datetime
feedEvents <- feedEvents %>%
  mutate(datetime = lubridate::mdy_hms(Timestamp)) %>%
  dplyr::select(-Timestamp)

# Subset to only include feeding events that occurred within the time range of this dataset
min <- min(dat$timestamp)
max <- max(dat$timestamp)
feedEvents <- feedEvents %>%
  filter(datetime >= min & datetime <= max)
nrow(feedEvents)
head(feedEvents)
table(feedEvents$area)
```

Okay, now that we have that data, we critically need access to the feeding station data so that we can match these carcass drops to lat/long.

```{r}
feedingStations <- read.csv("data/feeding_station_south_coordinates.xlsx - Sheet1.csv")
head(feedingStations)

# Are we going to be able to join these by name? I am not optimistic...
feedEvents$feeding_station %in% feedingStations$Feeding_station # awesome!!! oh my gosh.

# okay, let's join the coordinates
feedEvents <- feedEvents %>%
  left_join(feedingStations %>%
              dplyr::select(Feeding_station, lat, long),
            by = c("feeding_station" = "Feeding_station")) %>%
  mutate(lat = as.numeric(lat),
         long = as.numeric(long))
head(feedEvents)


# Remove any missing values. Later, will need to ask Gideon why these coordinates are missing, and see what we can do about it. But for now, this is just a proof of concept.
feedEvents <- feedEvents %>%
  filter(!is.na(lat) & !is.na(long))

# Now make it an sf object
feedEvents <- feedEvents %>%
  sf::st_as_sf(., coords = c("long", "lat"), remove = FALSE) %>%
  dplyr::select(-c(death_of_carcass_known, hours_since_death, origin_carcass, ranger, remarks))
```

Do some preliminary plotting

```{r}
mask <- suppressMessages(sf::st_read("data/CutOffRegion.kml"))
datMasked <- vultureUtils::maskData(dataset = dat, mask = mask, longCol = "location_long.1", latCol = "location_lat.1", crs = "WGS84")
# Get bounding box
lon <- range(datMasked$location_long)
lat <- range(datMasked$location_lat)

map <- ggmap::get_stamenmap(bbox = c(lon[1], lat[1], lon[2], lat[2]), zoom = 7, maptype = "terrain-background")
map

test <- datMasked[1:100,] %>%
  sf::st_set_crs("WGS84")

# Get one individual
test <- datMasked %>%
  filter(trackId == "T61w")

# Get bounding box for this indiv
lon <- range(test$location_long)
lat <- range(test$location_lat)

map <- ggmap::get_stamenmap(bbox = c(lon[1], lat[1], lon[2], lat[2]), zoom = 10, maptype = "terrain-background")

# Make the map
ggmap(map)+
  geom_point(data = test, aes(x = location_long.1, y = location_lat.1, col = ground_speed), size = 0.2)+
  geom_path(data = test, aes(x = location_long.1, y = location_lat.1), size = 0.02)+
  scale_color_viridis_c()

# Let's now do this separately for different years
unique(lubridate::year(test$dateOnly))

t20 <- test %>%
  filter(lubridate::year(dateOnly) == 2020)
t21 <- test %>%
  filter(lubridate::year(dateOnly) == 2021)
t22 <- test %>%
  filter(lubridate::year(dateOnly) == 2022)

lon <- range(t20$location_long)
lat <- range(t20$location_lat)
map <- ggmap::get_stamenmap(bbox = c(lon[1], lat[1], lon[2], lat[2]), zoom = 10, maptype = "terrain-background")
ggmap(map)+
  geom_point(data = t20, aes(x = location_long.1, y = location_lat.1, col = ground_speed), size = 0.2)+
  geom_path(data = t20, aes(x = location_long.1, y = location_lat.1), size = 0.02)+
  scale_color_viridis_c()

lon <- range(t21$location_long)
lat <- range(t21$location_lat)
map <- ggmap::get_stamenmap(bbox = c(lon[1], lat[1], lon[2], lat[2]), zoom = 10, maptype = "terrain-background")
ggmap(map)+
  geom_point(data = t21, aes(x = location_long.1, y = location_lat.1, col = ground_speed), size = 0.2)+
  geom_path(data = t21, aes(x = location_long.1, y = location_lat.1), size = 0.02)+
  scale_color_viridis_c()

lon <- range(t22$location_long)
lat <- range(t22$location_lat)
map <- ggmap::get_stamenmap(bbox = c(lon[1], lat[1], lon[2], lat[2]), zoom = 10, maptype = "terrain-background")
ggmap(map)+
  geom_point(data = t22, aes(x = location_long.1, y = location_lat.1, col = ground_speed), size = 0.2)+
  geom_path(data = t22, aes(x = location_long.1, y = location_lat.1), size = 0.02)+
  scale_color_viridis_c()
```

Okay, now that I know how to plot points and I know when and where the feeding events have occurred, time to plot points around each feeding station, color-coded by individual, around the time of the feeding events.

```{r warning=F}
head(feedEvents)
# plot just the feeding events
feedEvents %>%
  ggplot(aes(x = long, y = lat, col = as.numeric(datetime)))+
  geom_point(size = 2)+
  scale_color_viridis_c()

# Let's pick the most recent feeding event to test with
event <- feedEvents %>%
  slice(1)

# Filter the data to just get the data 2 hours before up to 24 hours later than the feeding time.
thisEvent <- datMasked %>%
  filter(timestamp > event$datetime[1] - lubridate::as.duration("2 hours") & timestamp < event$datetime[1] + lubridate::as.duration("200 hours"))
nrow(thisEvent) # 925 points
length(unique(thisEvent$trackId)) # 26 individuals
# I have not yet restricted this spatially.

bbox <- bboxFromRad(lon = event$long, lat = event$lat, kmDist = 3)
map <- ggmap::get_stamenmap(bbox = bbox, zoom = 10, maptype = "terrain-background")
ggmap(map)+
  geom_point(data = thisEvent, aes(x = location_long.1, y = location_lat.1, col = trackId), size = 1)+
  #geom_path(data = thisEvent, aes(x = location_long.1, y = location_lat.1, col = trackId), size = 0.5)+
  geom_point(data = event, aes(x = long, y = lat), col = "black", size = 3)+
  scale_color_viridis_d()+
  theme(legend.position = "none")
```



