---
title: "Network investigation (EcolEvol paper)"
format: html
editor: visual
---

## Drilling into how the network code works

```{r load-packages}
#| output: false
library(vultureUtils)
library(tidyverse)
library(sf)
```

For this investigation, I'm going to be working with data from December 2020 (2020-12-01) through June 2021 (2021-06-30), because that's the time interval that was used for the EE paper.

```{r define-dates}
minDate <- lubridate::ymd("2020-12-01")
maxDate <- lubridate::ymd("2021-06-30")
```

Let's begin by getting that data. Since we want to remove invalid periods anyway, and since my purpose here isn't to perfectly match the dataset that Nitika was using, I'm going to go ahead and use the dataset prepared in dataPrep.Rmd, which is datAnnotCleaned.Rda. I've recently updated this dataset to include data through the end of 2022, but that's not going to matter for this investigation, since I'll be subsetting it to the above dates anyway.

```{r load-subset-data}
#| output: false
load("data/datAnnotCleaned.Rda")
mask <- sf::st_read("data/CutOffRegion.kml")
roostPolygons <- sf::st_read("data/AllRoostPolygons.kml", 
                             quiet = TRUE) %>%
  sf::st_transform("WGS84")
subsetted <- datAnnotCleaned %>%
  filter(timestamp >= minDate & timestamp <= maxDate)
```

Now, using the functions in vultureUtils, create a co-flight edge list.

```{r}
# Define the args that will be needed to manually step through getEdges.
speedThreshLower = 5
speedThreshUpper = NULL
roostBuffer = 50
consecThreshold = 2
distThreshold = 1000
timeThreshold = "10 minutes"
quiet = T
includeAllVertices = F
# Manually stepping through the guts of getEdges:
dataset <- subsetted

# Argument checks
checkmate::assertDataFrame(dataset)
checkmate::assertClass(roostPolygons, "sf")
checkmate::assertNumeric(roostBuffer, len = 1)
checkmate::assertNumeric(consecThreshold, len = 1)
checkmate::assertNumeric(distThreshold, len = 1)
checkmate::assertNumeric(speedThreshUpper, len = 1, null.ok = TRUE)
checkmate::assertNumeric(speedThreshLower, len = 1, null.ok = TRUE)
checkmate::assertCharacter(timeThreshold, len = 1)

# Get all unique individuals before applying any filtering
if(includeAllVertices){
  uniqueIndivs <- unique(dataset$trackId)
}

# Restrict interactions based on ground speed
filteredData <- vultureUtils::filterLocs(df = dataset,
                                         speedThreshUpper = speedThreshUpper,
                                         speedThreshLower = speedThreshLower)

# Buffer the roost polygons
roostPolygons <- convertAndBuffer(roostPolygons, dist = roostBuffer)

# Exclude any points that fall within a (buffered) roost polygon
points <- filteredData[lengths(sf::st_intersects(filteredData, roostPolygons)) == 0,]

# If there are no rows left after filtering, return an empty data frame with the appropriate format.
if(nrow(points) == 0){
  dummy <- data.frame(timegroup = as.integer(),
                      ID1 = as.character(),
                      ID2 = as.character(),
                      distance = as.numeric(),
                      minTimestamp = as.POSIXct(character()),
                      maxTimestamp = as.POSIXct(character()))
  warning("After filtering, the dataset had 0 rows. Returning an empty edge list.")
  if(includeAllVertices){
    toReturn <- list("edges" = dummy,
                     "allVertices" = uniqueIndivs)
    #return(toReturn)
  }else{
    #return(dummy)
  }
}else{
  if(quiet == T){
    edges <- suppressWarnings(vultureUtils::spaceTimeGroups(dataset = points,
                                                            distThreshold = distThreshold,
                                                            consecThreshold = consecThreshold,
                                                            timeThreshold = timeThreshold))
  }else{
    edges <- vultureUtils::spaceTimeGroups(dataset = points,
                                           distThreshold = distThreshold,
                                           consecThreshold = consecThreshold,
                                           timeThreshold = timeThreshold)
  }
  if(includeAllVertices){
    toReturn <- list("edges" = edges,
                     "allVertices" = uniqueIndivs)
  }else{
    #return(edges)
  }
}
nrow(edges)
fromVU <- getEdges(dataset, roostPolygons = roostPolygons, roostBuffer = 50, consecThreshold = 2, distThreshold = 1000, speedThreshUpper = NULL, speedThreshLower = 5, timeThreshold = "10 minutes", quiet = T, includeAllVertices = F)

# I cannot for the life of me figure out why these row numbers are not lining up...
```


How many co-feeding, co-flight, co-roosting per month, total? Per individual? \*\*priority.

```{r}

```

For consecutive 10-minute slices, do they count as multiple or one

What is the duration of "an interaction"

Stop criterion: need to have stopped interacting for two consecutive 10-minute time slices?

When does the SRI correction happen? Does it happen for each ten-minute interval, or overall?

Do this first. When does she implement it?

For each project, what's the region that we include and which individuals are we including? Use those for SRI.

How does it deal with multiple interacting individuals?
